// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/Logger ../../../../../core/MapUtils ../../../../../core/maybe ../../../../../chunks/quat ../../../../../chunks/quatf64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../MeshMaterialMetallicRoughness ../../../MeshTransform ../../georeference ./buffer ./geometry ./types ./imageutils ../../../../../views/3d/glTF/internal/resourceUtils ../../../../../views/webgl/enums".split(" "),function(J,C,P,m,Q,K,L,v,R,S,T,M,N,h,D,E,l){const F=C.getLogger("gltf");
C=function(){function O(b,a,c){this.params={};this._materialMap=[];this._imageMap=new Map;this._textureMap=new Map;this.gltf={asset:{version:"2.0",copyright:b.copyright,generator:b.generator},extras:{options:a,binChunkBuffer:null,promises:[]}};c&&(this.params=c);this._addScenes(b)}var p=O.prototype;p._addScenes=function(b){this.gltf.scene=b.defaultScene;const a=this.gltf.extras,c=a.options.bufferOutputType===h.BufferOutputType.GLB||a.options.imageOutputType===h.ImageOutputType.GLB;c&&(a.binChunkBuffer=
new M.Buffer(this.gltf));b.forEachScene(d=>{this._addScene(d)});c&&a.binChunkBuffer.finalize()};p._addScene=function(b){this.gltf.scenes||(this.gltf.scenes=[]);const a={};b.name&&(a.name=b.name);b.forEachNode(c=>{a.nodes||(a.nodes=[]);c=this._addNode(c);a.nodes.push(c)});this.gltf.scenes.push(a)};p._addNode=function(b){this.gltf.nodes||(this.gltf.nodes=[]);const a={};b.name&&(a.name=b.name);var c=b.translation;L.exactEquals(c,v.ZEROS)||(a.translation=v.clone(c));c=b.rotation;Q.exactEquals(c,K.IDENTITY)||
(a.rotation=K.clone(c));c=b.scale;L.exactEquals(c,v.ONES)||(a.scale=v.clone(c));b.mesh&&b.mesh.vertexAttributes.position?a.mesh=this._addMesh(b.mesh):b.forEachNode(d=>{a.children||(a.children=[]);d=this._addNode(d);a.children.push(d)});b=this.gltf.nodes.length;this.gltf.nodes.push(a);return b};p._addMesh=function(b){this.gltf.meshes||(this.gltf.meshes=[]);const a={primitives:[]};var c=this.gltf.extras;const d=c.options.bufferOutputType===h.BufferOutputType.GLB;c=d?c.binChunkBuffer:new M.Buffer(this.gltf);
this.params.origin||(this.params.origin=N.computeOrigin(b));var f=this.params.ignoreLocalTransform?m.applySome(b.transform,G=>new S({origin:[G.origin[0],G.origin[1],G.origin[2]],geographic:!1})):b.transform,e=T.ungeoreferenceByTransform(b.vertexAttributes,f,this.params.origin,{geographic:this.params.geographic,unit:"meters"});N.smoothNormals(b,e);this._flipYZAxis(e);f=c.addBufferView(l.DataType.FLOAT,h.AttributeType.VEC3,h.TargetBuffer.ARRAY_BUFFER);let g;e.normal&&(g=c.addBufferView(l.DataType.FLOAT,
h.AttributeType.VEC3,h.TargetBuffer.ARRAY_BUFFER));let n;b.vertexAttributes.uv&&(n=c.addBufferView(l.DataType.FLOAT,h.AttributeType.VEC2,h.TargetBuffer.ARRAY_BUFFER));let k;e.tangent&&(k=c.addBufferView(l.DataType.FLOAT,h.AttributeType.VEC4,h.TargetBuffer.ARRAY_BUFFER));let q;b.vertexAttributes.color&&(q=c.addBufferView(l.DataType.UNSIGNED_BYTE,h.AttributeType.VEC4,h.TargetBuffer.ARRAY_BUFFER));f.startAccessor("POSITION");g&&g.startAccessor("NORMAL");n&&n.startAccessor("TEXCOORD_0");k&&k.startAccessor("TANGENT");
q&&q.startAccessor("COLOR_0");var r=e.position.length/3;const {position:H,normal:w,tangent:t}=e,{color:u,uv:I}=b.vertexAttributes;for(e=0;e<r;++e)f.push(H[3*e]),f.push(H[3*e+1]),f.push(H[3*e+2]),g&&m.isSome(w)&&(g.push(w[3*e]),g.push(w[3*e+1]),g.push(w[3*e+2])),n&&m.isSome(I)&&(n.push(I[2*e]),n.push(I[2*e+1])),k&&m.isSome(t)&&(k.push(t[4*e]),k.push(t[4*e+1]),k.push(t[4*e+2]),k.push(t[4*e+3])),q&&m.isSome(u)&&(q.push(u[4*e]),q.push(u[4*e+1]),q.push(u[4*e+2]),q.push(u[4*e+3]));r=f.endAccessor();r=this._addAccessor(f.index,
r);if(g){var x=g.endAccessor();x=this._addAccessor(g.index,x)}if(n){var y=n.endAccessor();y=this._addAccessor(n.index,y)}if(k){var z=k.endAccessor();z=this._addAccessor(k.index,z)}if(q){var A=q.endAccessor();A=this._addAccessor(q.index,A)}let B;b.components&&0<b.components.length&&b.components[0].faces?(B=c.addBufferView(l.DataType.UNSIGNED_INT,h.AttributeType.SCALAR,h.TargetBuffer.ELEMENT_ARRAY_BUFFER),this._addMeshVertexIndexed(B,b.components,a,r,x,y,z,A)):this._addMeshVertexNonIndexed(b.components,
a,r,x,y,z,A);f.finalize();g&&g.finalize();n&&n.finalize();k&&k.finalize();B&&B.finalize();q&&q.finalize();d||c.finalize();b=this.gltf.meshes.length;this.gltf.meshes.push(a);return b};p._flipYZAxis=function({position:b,normal:a,tangent:c}){this._flipYZBuffer(b,3);this._flipYZBuffer(a,3);this._flipYZBuffer(c,4)};p._flipYZBuffer=function(b,a){if(!m.isNone(b))for(let c=1,d=2;c<b.length;c+=a,d+=a){const f=b[c];b[c]=b[d];b[d]=-f}};p._addMaterial=function(b){if(null!==b){var a=this._materialMap.indexOf(b);
if(-1!==a)return a;this.gltf.materials||(this.gltf.materials=[]);a={};switch(b.alphaMode){case "mask":a.alphaMode=h.AlphaMode.MASK;break;case "auto":case "blend":a.alphaMode=h.AlphaMode.BLEND}.5!==b.alphaCutoff&&(a.alphaCutoff=b.alphaCutoff);b.doubleSided&&(a.doubleSided=b.doubleSided);a.pbrMetallicRoughness={};var c=d=>{d=d.toRgba();d[0]=(d[0]/255)**2.1;d[1]=(d[1]/255)**2.1;d[2]=(d[2]/255)**2.1;return d};m.isSome(b.color)&&(a.pbrMetallicRoughness.baseColorFactor=c(b.color));m.isSome(b.colorTexture)&&
(a.pbrMetallicRoughness.baseColorTexture={index:this._addTexture(b.colorTexture)});m.isSome(b.normalTexture)&&(a.normalTexture={index:this._addTexture(b.normalTexture)});b instanceof R?(m.isSome(b.emissiveTexture)&&(a.emissiveTexture={index:this._addTexture(b.emissiveTexture)}),m.isSome(b.emissiveColor)&&(c=c(b.emissiveColor),a.emissiveFactor=[c[0],c[1],c[2]]),m.isSome(b.occlusionTexture)&&(a.occlusionTexture={index:this._addTexture(b.occlusionTexture)}),m.isSome(b.metallicRoughnessTexture)&&(a.pbrMetallicRoughness.metallicRoughnessTexture=
{index:this._addTexture(b.metallicRoughnessTexture)}),a.pbrMetallicRoughness.metallicFactor=b.metallic,a.pbrMetallicRoughness.roughnessFactor=b.roughness):(a.pbrMetallicRoughness.metallicFactor=1,a.pbrMetallicRoughness.roughnessFactor=1,F.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back."));c=this.gltf.materials.length;this.gltf.materials.push(a);this._materialMap.push(b);return c}};p._addTexture=function(b){const a=this.gltf.textures??
[];this.gltf.textures=a;return P.getOrCreateMapValue(this._textureMap,b,()=>{const c={sampler:this._addSampler(b),source:this._addImage(b)},d=a.length;a.push(c);return d})};p._addImage=function(b){var a=this._imageMap.get(b);if(null!=a)return a;this.gltf.images||(this.gltf.images=[]);const c={};if(b.url)c.uri=b.url;else{a=b.data;c.extras=a;for(var d=0;d<this.gltf.images.length;++d)if(a===this.gltf.images[d].extras)return d;d=this.gltf.extras;switch(d.options.imageOutputType){case h.ImageOutputType.GLB:const f=
d.binChunkBuffer.addBufferView(l.DataType.UNSIGNED_BYTE,h.AttributeType.SCALAR);E.isEncodedMeshTexture(a)?m.isSome(a.data)&&f.writeOutToBuffer(a.data,0):(a=D.imageToArrayBuffer(a).then(({data:e,type:g})=>{c.mimeType=g;return e}),f.writeAsync(a).then(()=>{f.finalize()}));c.bufferView=f.index;break;case h.ImageOutputType.DataURI:E.isEncodedMeshTexture(a)?F.warnOnce("Image export for basis compressed textures not available."):c.uri=D.imageToDataURI(a);break;default:E.isEncodedMeshTexture(a)?F.warnOnce("Image export for basis compressed textures not available."):
d.promises.push(D.imageToArrayBuffer(a).then(({data:e,type:g})=>{c.uri=e;c.mimeType=g}))}}a=this.gltf.images.length;this.gltf.images.push(c);this._imageMap.set(b,a);return a};p._addSampler=function(b){this.gltf.samplers||(this.gltf.samplers=[]);var a=l.TextureWrapMode.REPEAT;let c=l.TextureWrapMode.REPEAT;if("string"===typeof b.wrap)switch(b.wrap){case "clamp":c=a=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=a=l.TextureWrapMode.MIRRORED_REPEAT}else{switch(b.wrap.vertical){case "clamp":c=
l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=l.TextureWrapMode.MIRRORED_REPEAT}switch(b.wrap.horizontal){case "clamp":a=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":a=l.TextureWrapMode.MIRRORED_REPEAT}}b={wrapS:a,wrapT:c};for(a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(b)===JSON.stringify(this.gltf.samplers[a]))return a;a=this.gltf.samplers.length;this.gltf.samplers.push(b);return a};p._addAccessor=function(b,a){this.gltf.accessors||(this.gltf.accessors=[]);b={bufferView:b,
byteOffset:a.byteOffset,componentType:a.componentType,count:a.count,type:a.type,min:a.min,max:a.max,name:a.name};a.normalized&&(b.normalized=!0);a=this.gltf.accessors.length;this.gltf.accessors.push(b);return a};p._addMeshVertexIndexed=function(b,a,c,d,f,e,g,n){for(const k of a){b.startAccessor("INDICES");for(a=0;a<k.faces.length;++a)b.push(k.faces[a]);a=b.endAccessor();a={attributes:{POSITION:d},indices:this._addAccessor(b.index,a),material:this._addMaterial(k.material)};f&&"flat"!==k.shading&&(a.attributes.NORMAL=
f);e&&(a.attributes.TEXCOORD_0=e);g&&"flat"!==k.shading&&(a.attributes.TANGENT=g);n&&(a.attributes.COLOR_0=n);c.primitives.push(a)}};p._addMeshVertexNonIndexed=function(b,a,c,d,f,e,g){c={attributes:{POSITION:c}};d&&(c.attributes.NORMAL=d);f&&(c.attributes.TEXCOORD_0=f);e&&(c.attributes.TANGENT=e);g&&(c.attributes.COLOR_0=g);b&&(c.material=this._addMaterial(b[0].material));a.primitives.push(c)};return O}();J.GLTF=C;Object.defineProperty(J,Symbol.toStringTag,{value:"Module"})});