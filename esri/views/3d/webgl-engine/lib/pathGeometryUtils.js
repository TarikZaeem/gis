// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/mat2f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/plane ../../../../geometry/support/ray ./Attribute ./FloatArray ./GeometryUtil ./Indices ./VertexAttribute ../materials/internal/MaterialUtil".split(" "),function(u,C,V,O,P,r,t,n,v,H,W,A,B,Q,I,x,X){function J(){return{up:v.create(),
right:v.create()}}let Y=function(){function f(){this.pos=v.create();this.posES=v.create();this.vLeft=v.create();this.vRight=v.create();this.vMinSiblingLength=0;this.frame=J();this.rotationFrameUp=v.create();this.rotationRight=t.create();this.rotationAngle=0;this.miterStretch=V.create();this.maxStretchDistance=0}f.prototype.setFrameFromUpVector=function(g){n.copy(this.frame.up,g);n.add(E,this.vLeft,this.vRight);n.normalize(E,E);n.scale(K,this.frame.up,n.dot(E,this.frame.up));n.subtract(F,E,K);n.normalize(F,
F);n.cross(this.frame.right,F,this.frame.up)};return f}(),L=function(){function f(){this.vertices=[];this.vertexIndices=[];this.vertexNormals=[];this.poles=[];this.poleIndices=[]}var g=f.prototype;g.addVertex=function(c,a){this.vertices.push(t.clone(c));this.vertexNormals.push(t.clone(a));return this.vertices.length-1};g.addPole=function(c,a=null){this.poles.push({position:t.clone(c),normal:a?t.clone(a):null});return this.poles.length-1};g.addSegment=function(c,a=null){this.vertexIndices.push(c.v0);
this.vertexIndices.push(c.v1);a&&(this.poleIndices.push(a.v0),this.poleIndices.push(a.v1))};g.translate=function(c,a){for(const b of this.vertices)b[0]+=c,b[1]+=a;for(const b of this.poles)b.position[0]+=c,b.position[1]+=a};C._createClass(f,[{key:"numSegments",get:function(){return this.vertexIndices.length/2}}]);return f}(),Z=function(){function f(g){this.vertices=g;this.offset=v.create();this.xform=P.create();n.copy(this.offset,this.vertices[Math.floor((g.length-1)/2)].pos);for(const c of this.vertices)n.subtract(c.pos,
c.pos,this.offset);O.translate(this.xform,this.xform,this.offset);this.updatePathVertexInformation()}f.prototype.updatePathVertexInformation=function(){const g=this.vertices.length;var c=this.vertices[0];c.index=0;c.vLeft=v.create();n.subtract(c.vRight,this.vertices[1].pos,c.pos);let a=n.length(c.vRight);c.vMinSiblingLength=a;n.normalize(c.vRight,c.vRight);var b=c;for(c=1;c<g;++c){const d=this.vertices[c];d.index=c;d.vLeft=b.vRight;c<g-1?(n.subtract(d.vRight,this.vertices[c+1].pos,d.pos),b=n.length(d.vRight),
d.vMinSiblingLength=Math.min(a,b),a=b,n.normalize(d.vRight,d.vRight)):(n.copy(d.vRight,d.vLeft),d.vMinSiblingLength=a);b=d}};return f}(),aa=function(){function f(){}var g=f.prototype;g.numProfilesPerJoin=function(){return 1};g.extrude=function(c,a,b){for(let d=0;d<a.vertices.length;++d)b(c.index,c.frame,a.vertices[d],a.vertexNormals[d],!1)};return f}(),ca=function(){function f(c=.8*Math.PI,a=1){this.cutoffAngle=c;this.numBendSubdivisions=a}var g=f.prototype;g.numProfilesPerJoin=function(){return this.numBendSubdivisions+
1};g.extrude=function(c,a,b){var d=ba;if(Math.abs(c.rotationAngle)>=this.cutoffAngle)for(var e=0;e<this.numBendSubdivisions+1;++e){O.fromRotation(R,.5*-c.rotationAngle+e*c.rotationAngle/this.numBendSubdivisions,c.rotationFrameUp);var h=d,l=c.frame,k=R;n.transformMat4(h.up,l.up,k);n.transformMat4(h.right,l.right,k);for(h=0;h<a.vertices.length;++h)0<=r.dot(a.vertices[h],c.rotationRight)*c.rotationAngle?b(c.index,d,a.vertices[h],a.vertexNormals[h],!1):(r.transformMat2(D,a.vertices[h],c.miterStretch),
b(c.index,c.frame,D,a.vertexNormals[h],!0))}else for(d=0;d<this.numBendSubdivisions+1;++d)for(e=0;e<a.vertices.length;++e)h=0<=r.dot(a.vertices[e],c.rotationRight)*c.rotationAngle,r.transformMat2(D,a.vertices[e],c.miterStretch),b(c.index,c.frame,D,a.vertexNormals[e],h?!1:!0)};return f}(),G=function(){function f(){}f.prototype.rebuildConnectingProfileGeometry=function(g,c,a){for(let b=0;b<c.vertices.length;++b)a(g.index,g.frame,c.vertices[b],c.vertexNormals[b],0,0)};return f}(),da=function(f){function g(){return f.call(this)||
this}C._inheritsLoose(g,f);var c=g.prototype;c.getNumVertices=function(){return 0};c.getNumIndices=function(){return 0};c.rebuildCapGeometry=function(){};c.buildTopology=function(){};return g}(G),ea=function(f){function g(a,b=0,d=!1){var e=f.call(this)||this;e.profile=a;e.profilePlaneOffset=b;e.flip=d;return e}C._inheritsLoose(g,f);var c=g.prototype;c.getNumVertices=function(){return this.profile.vertices.length};c.getNumIndices=function(){return 3*this.profile.numSegments};c.rebuildConnectingProfileGeometry=
function(a,b,d){for(let e=0;e<b.vertices.length;++e)d(a.index,a.frame,b.vertices[e],b.vertexNormals[e],this.profilePlaneOffset,0)};c.rebuildCapGeometry=function(a,b){const d=M;r.set(d,0,0);const e=this.flip?1:-1;for(let h=0;h<this.profile.vertices.length;++h)b(a.index,a.frame,this.profile.vertices[h],d,this.profilePlaneOffset,e)};c.buildTopology=function(a,b){a=this.vertexBufferStart+this.profile.vertexIndices[0];for(let d=1;d<this.profile.numSegments;++d){const e=this.vertexBufferStart+this.profile.vertexIndices[2*
d],h=this.vertexBufferStart+this.profile.vertexIndices[2*d+1];this.flip?b(h,e,a):b(a,e,h)}};return g}(G),fa=function(f){function g(a){var b=f.call(this)||this;b.flip=!1;b.sign=0;b.breakNormals=!1;b.numSegments=3;b.profile=a.profile;b.flip=a.flip;b.sign=b.flip?1:-1;b.breakNormals=a.breakNormals;b.numSegments=a.subdivisions;return b}C._inheritsLoose(g,f);var c=g.prototype;c.getNumVertices=function(){let a=0;a=this.profile.vertices.length*(this.numSegments-1);this.breakNormals&&(a+=this.profile.vertices.length);
return a+=this.profile.poles.length};c.getNumIndices=function(){let a;a=2*this.profile.numSegments*(this.numSegments-1);for(let b=0;b<this.profile.numSegments;++b)a=this.profile.poleIndices[this.profile.vertexIndices[2*b]]===this.profile.poleIndices[this.profile.vertexIndices[2*b+1]]?a+1:a+2;return 3*a};c.rebuildCapGeometry=function(a,b){const d=a.frame,e=.5*this.sign,h=D,l=M;r.set(l,0,0);for(var k=0;k<this.profile.poles.length;++k){var q=this.profile.poles[k];q.normal?b(a.index,d,q.position,q.normal,
e,0):b(a.index,d,q.position,l,e,this.sign)}if(this.breakNormals)for(k=0;k<this.profile.vertices.length;++k)b(a.index,d,this.profile.vertices[k],this.profile.vertexNormals[k],0,0);for(k=0;k<this.numSegments-1;++k){var m=(1-(k+1)/this.numSegments)*Math.PI*.5;q=Math.sin(m);m=Math.cos(m);for(let p=0;p<this.profile.vertices.length;++p){const w=this.profile.poles[this.profile.poleIndices[p]];r.subtract(h,this.profile.vertices[p],w.position);r.scale(h,h,q);w.normal?(r.add(h,h,w.position),b(a.index,d,h,w.normal,
e*m,0)):(r.normalize(l,h),r.scale(l,l,q),r.add(h,h,w.position),b(a.index,d,h,l,e*m,this.sign*m))}}};c.buildTopology=function(a,b){a=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex;const d=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let e=0;e<this.profile.numSegments;++e){const h=this.profile.vertexIndices[2*e],l=this.profile.vertexIndices[2*e+1],
k=this.vertexBufferStart+this.profile.poleIndices[h],q=this.vertexBufferStart+this.profile.poleIndices[l];let m=a+h,p=a+l;for(let w=0;w<this.numSegments-1;++w){const y=d+w*this.profile.vertices.length+h,z=d+w*this.profile.vertices.length+l;this.flip?(b(y,p,m),b(p,y,z)):(b(m,p,y),b(z,y,p));m=y;p=z}this.flip?(b(k,p,m),k!==q&&b(k,q,p)):(b(m,p,k),k!==q&&b(p,q,k))}};return g}(G),ha=function(){function f(c,a,b,d,e,h={}){this.options=h;this.numNormalsTotal=this.numVerticesTotal=this.numExtrusionProfiles=
this._extrusionVertexCount=0;this.profile=a;this.path=c;this.extruder=b;this.startCap=d;this.endCap=e;c=this.path.vertices.length-2;this.numExtrusionProfiles=b.numProfilesPerJoin()*c+2;this.numNormalsTotal=this.numVerticesTotal=a.vertices.length*this.numExtrusionProfiles;this.startCap.vertexBufferStart=this.numVerticesTotal;a=this.startCap.getNumVertices();this.numVerticesTotal+=a;this.numNormalsTotal+=a;this.endCap.vertexBufferStart=this.numVerticesTotal;a=this.endCap.getNumVertices();this.numVerticesTotal+=
a;this.numNormalsTotal+=a;this.pathVertexData=B.newFloatArray(1*this.numVerticesTotal);this.profileRightAxisData=B.newFloatArray(4*this.numVerticesTotal);this.profileUpAxisData=B.newFloatArray(4*this.numVerticesTotal);this.profileVertexAndNormalData=B.newFloatArray(4*this.numVerticesTotal);this.originData=B.newFloatArray(3*this.path.vertices.length);this._rebuildGeometry();this.buildTopology()}var g=f.prototype;g.emitVertex=function(c,a,b,d,e){this.profileRightAxisData[4*this._extrusionVertexCount]=
a.right[0];this.profileRightAxisData[4*this._extrusionVertexCount+1]=a.right[1];this.profileRightAxisData[4*this._extrusionVertexCount+2]=a.right[2];this.profileUpAxisData[4*this._extrusionVertexCount]=a.up[0];this.profileUpAxisData[4*this._extrusionVertexCount+1]=a.up[1];this.profileUpAxisData[4*this._extrusionVertexCount+2]=a.up[2];this.profileVertexAndNormalData[4*this._extrusionVertexCount]=b[0];this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=b[1];this.profileVertexAndNormalData[4*
this._extrusionVertexCount+2]=d[0];this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=d[1];this.pathVertexData[this._extrusionVertexCount]=c;e?(c=this.path.vertices[c],this.profileRightAxisData[4*this._extrusionVertexCount+3]=c.rotationRight[0]*c.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=c.rotationRight[1]*c.maxStretchDistance):(this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0);++this._extrusionVertexCount};
g.emitCapVertex=function(c,a,b,d,e,h){this.profileRightAxisData[4*this._extrusionVertexCount]=a.right[0];this.profileRightAxisData[4*this._extrusionVertexCount+1]=a.right[1];this.profileRightAxisData[4*this._extrusionVertexCount+2]=a.right[2];this.profileUpAxisData[4*this._extrusionVertexCount]=a.up[0];this.profileUpAxisData[4*this._extrusionVertexCount+1]=a.up[1];this.profileUpAxisData[4*this._extrusionVertexCount+2]=a.up[2];this.profileVertexAndNormalData[4*this._extrusionVertexCount]=b[0];this.profileVertexAndNormalData[4*
this._extrusionVertexCount+1]=b[1];this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=d[0];this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=d[1];this.pathVertexData[this._extrusionVertexCount]=c;this.profileRightAxisData[4*this._extrusionVertexCount+3]=e;this.profileUpAxisData[4*this._extrusionVertexCount+3]=h;++this._extrusionVertexCount};g._rebuildGeometry=function(){const c=(d,e,h,l,k)=>this.emitVertex(d,e,h,l,k),a=(d,e,h,l,k,q)=>this.emitCapVertex(d,e,h,l,k,q);this._extrusionVertexCount=
0;for(var b of this.path.vertices)this.originData[3*b.index]=b.pos[0],this.originData[3*b.index+1]=b.pos[1],this.originData[3*b.index+2]=b.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,a);for(b=1;b<this.path.vertices.length-1;++b)this.extruder.extrude(this.path.vertices[b],this.profile,c);this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,a);this.startCap.rebuildCapGeometry(this.path.vertices[0],a);this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-
1],a)};g.buildTopology=function(){const c=this.profile.vertices.length,a=this.profile.numSegments,b=this.numExtrusionProfiles-1;var d=a*b*6;this.startCap.indexBufferStart=d;this.startCap.firstProfileVertexIndex=0;d+=this.startCap.getNumIndices();this.endCap.indexBufferStart=d;this.endCap.firstProfileVertexIndex=c*(this.numExtrusionProfiles-1);const e=[],h=[],l=[];d=(k,q,m)=>{e.push(k);e.push(q);e.push(m);h.push(k);h.push(q);h.push(m);l.push(this.pathVertexData[k]);l.push(this.pathVertexData[q]);l.push(this.pathVertexData[m])};
for(let k=0;k<a;++k){const q=this.profile.vertexIndices[2*k],m=this.profile.vertexIndices[2*k+1];for(let p=0;p<b;++p){const w=p*c+q,y=(p+1)*c+m,z=p*c+m;d(w,(p+1)*c+q,y);d(w,y,z)}}this.startCap.buildTopology(this.path.vertices[0],d);this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],d);this.vertexIndices=I.compactIndices(e);this.normalIndices=I.compactIndices(h);this.pathVertexIndices=I.compactIndices(l)};g.onPathChanged=function(){this._rebuildGeometry()};return f}(),N=function(){function f(g){this.builder=
g}f.prototype.onPathChanged=function(){this.builder.onPathChanged()};C._createClass(f,[{key:"xform",get:function(){return this.builder.path.xform}}]);return f}(),U=function(f){function g(a){a=f.call(this,a)||this;a.vertexAttributePosition=null;a.vertexAttributeNormal=null;a.vertexAttributeColor=null;a.vertexAttributePosition=B.newFloatArray(3*a.builder.numVerticesTotal);a.vertexAttributeNormal=B.newFloatArray(3*a.builder.numNormalsTotal);a.vertexAttributeColor=new Uint8Array(4);a.vertexAttributeColor[0]=
255;a.vertexAttributeColor[1]=255;a.vertexAttributeColor[2]=255;a.vertexAttributeColor[3]=255;return a}C._inheritsLoose(g,f);var c=g.prototype;c.bakeVertexColors=function(a){this.vertexAttributeColor[0]=255*a[0];this.vertexAttributeColor[1]=255*a[1];this.vertexAttributeColor[2]=255*a[2];this.vertexAttributeColor[3]=255*(3<a.length?a[3]:1)};c.bake=function(a){this.size=a;for(let h=0;h<this.builder.numVerticesTotal;++h){var b=this.builder.pathVertexData[h],d=0===b||b===this.builder.path.vertices.length-
1;b*=3;var e=ia;n.set(e,this.builder.originData[b++],this.builder.originData[b++],this.builder.originData[b]);b=4*h;const l=K,k=D,q=E,m=ja,p=ka;let w=0,y=0;n.set(m,this.builder.profileRightAxisData[b],this.builder.profileRightAxisData[b+1],this.builder.profileRightAxisData[b+2]);n.set(p,this.builder.profileUpAxisData[b],this.builder.profileUpAxisData[b+1],this.builder.profileUpAxisData[b+2]);r.set(k,this.builder.profileVertexAndNormalData[b]*a[0],this.builder.profileVertexAndNormalData[b+1]*a[1]);
if(d)n.cross(q,p,m),w=this.builder.profileRightAxisData[b+3]*a[0],y=this.builder.profileUpAxisData[b+3];else{d=M;const z=la;r.set(d,this.builder.profileRightAxisData[b+3],this.builder.profileUpAxisData[b+3]);const S=r.length(d);r.normalize(d,d);const T=r.dot(k,d);if(Math.abs(T)>S){r.set(z,-d[1],d[0]);const ma=r.dot(k,z);r.scale(d,d,S*Math.sign(T));r.scale(z,z,ma);r.add(k,d,z)}n.set(q,0,0,0)}n.set(l,m[0]*k[0]+p[0]*k[1],m[1]*k[0]+p[1]*k[1],m[2]*k[0]+p[2]*k[1]);this.vertexAttributePosition[3*h]=e[0]+
l[0]+q[0]*w;this.vertexAttributePosition[3*h+1]=e[1]+l[1]+q[1]*w;this.vertexAttributePosition[3*h+2]=e[2]+l[2]+q[2]*w;e=D;r.set(e,this.builder.profileVertexAndNormalData[b+2],this.builder.profileVertexAndNormalData[b+3]);this.vertexAttributeNormal[3*h]=m[0]*e[0]+p[0]*e[1]+q[0]*y;this.vertexAttributeNormal[3*h+1]=m[1]*e[0]+p[1]*e[1]+q[1]*y;this.vertexAttributeNormal[3*h+2]=m[2]*e[0]+p[2]*e[1]+q[2]*y}};c.createGeometryData=function(){const a=[[x.VertexAttribute.POSITION,this.builder.vertexIndices],
[x.VertexAttribute.NORMAL,this.builder.normalIndices]],b=[[x.VertexAttribute.POSITION,new A.Attribute(this.vertexAttributePosition,3,!0)],[x.VertexAttribute.NORMAL,new A.Attribute(this.vertexAttributeNormal,3,!0)]];this.vertexAttributeColor&&(a.push([x.VertexAttribute.COLOR,Array(this.builder.vertexIndices.length).fill(0)]),b.push([x.VertexAttribute.COLOR,new A.Attribute(this.vertexAttributeColor,4)]));return{vertexAttributes:b,indices:a}};c.onPathChanged=function(){f.prototype.onPathChanged.call(this);
this.bake(this.size)};c.intersect=function(a,b,d){const e=this.builder.vertexIndices,h=new A.Attribute(this.vertexAttributePosition,3);X.intersectTriangles(a,b,0,e.length/3,e,h,void 0,void 0,d)};return g}(N),na=function(f){function g(c,a,b,d){var e=f.call(this,c)||this;e.sizeAttributeValue=a;e.colorAttributeValue=b;e.opacityAttributeValue=d;e.vvData=null;e.baked=new U(c);e.vvData=B.newFloatArray(4*e.builder.path.vertices.length);for(c=0;c<e.builder.path.vertices.length;++c)e.vvData[4*c]=a,e.vvData[4*
c+1]=b,e.vvData[4*c+2]=d,e.vvData[4*c+3]=0===c||c===e.builder.path.vertices.length-1?1:0;return e}C._inheritsLoose(g,f);g.prototype.createGeometryData=function(){return{vertexAttributes:[[x.VertexAttribute.POSITION,new A.Attribute(this.builder.originData,3,!0)],[x.VertexAttribute.PROFILERIGHT,new A.Attribute(this.builder.profileRightAxisData,4,!0)],[x.VertexAttribute.PROFILEUP,new A.Attribute(this.builder.profileUpAxisData,4,!0)],[x.VertexAttribute.PROFILEVERTEXANDNORMAL,new A.Attribute(this.builder.profileVertexAndNormalData,
4,!0)],[x.VertexAttribute.FEATUREVALUE,new A.Attribute(this.vvData,4,!0)]],indices:[[x.VertexAttribute.POSITION,this.builder.pathVertexIndices],[x.VertexAttribute.PROFILERIGHT,this.builder.vertexIndices],[x.VertexAttribute.PROFILEUP,this.builder.vertexIndices],[x.VertexAttribute.PROFILEVERTEXANDNORMAL,this.builder.vertexIndices],[x.VertexAttribute.FEATUREVALUE,this.builder.pathVertexIndices]]}};return g}(N);const ia=v.create(),D=t.create(),M=t.create(),la=t.create(),K=v.create(),E=v.create(),ja=v.create(),
ka=v.create(),F=v.create(),ba=J(),R=P.create();u.Builder=ha;u.CapBuilder=G;u.Extruder=function(){};u.FastUpdatePathGeometry=na;u.MiterExtruder=ca;u.NoCapBuilder=da;u.Path=Z;u.PathGeometryData=N;u.PathVertex=Y;u.Profile=L;u.RoundCapBuilder=fa;u.SimpleExtruder=aa;u.StaticPathGeometry=U;u.TriangulationCapBuilder=ea;u.computeMinimumRotationTangentFrame=function(f,g){let c=null;const a=f.vertices.length,b=v.create(),d=v.create(),e=v.create(),h=v.create(),l=v.create(),k=v.create(),q=H.create();let m=f.vertices[0];
n.copy(d,g);n.set(b,0,1,0);Q.makeOrthoBasisDirUpFallback(m.vRight,d,b,b,e,d,.99619469809);n.copy(m.frame.up,d);n.copy(m.frame.right,e);c=m;for(g=1;g<a;++g){m=f.vertices[g];n.add(l,m.vLeft,m.vRight);let p=n.length(l);0<p?(p=1/Math.sqrt(p),l[0]*=p,l[1]*=p,l[2]*=p):(l[0]=m.vRight[0],l[1]=m.vRight[1],l[2]=m.vRight[2]);n.add(k,c.pos,c.frame.up);H.fromPositionAndNormal(m.pos,l,q);H.intersectRay(q,W.wrap(k,m.vLeft),h)?(n.subtract(h,h,m.pos),n.normalize(d,h),n.cross(e,l,d),n.normalize(e,e)):Q.makeOrthoBasisDirUpFallback(l,
c.frame.up,c.frame.right,b,e,d,.99619469809);n.copy(m.frame.up,d);n.copy(m.frame.right,e);c=m}};u.creatQuadProfile=function(){const f=new L,g=t.fromValues(-.5,-.5),c=t.fromValues(.5,-.5),a=t.fromValues(.5,.5),b=t.fromValues(-.5,.5),d=t.fromValues(0,-1),e=t.fromValues(1,0),h=t.fromValues(0,1),l=t.fromValues(-1,0);f.addPole(t.fromValues(0,.5),h);f.addPole(t.fromValues(0,.5));f.addPole(t.fromValues(0,-.5));f.addPole(t.fromValues(0,-.5),d);f.addVertex(g,d);f.addVertex(c,d);f.addSegment({v0:0,v1:1},{v0:3,
v1:3});f.addVertex(c,e);f.addVertex(a,e);f.addSegment({v0:2,v1:3},{v0:2,v1:1});f.addVertex(a,h);f.addVertex(b,h);f.addSegment({v0:4,v1:5},{v0:0,v1:0});f.addVertex(b,l);f.addVertex(g,l);f.addSegment({v0:6,v1:7},{v0:1,v1:2});return f};u.createCircleProfile=function(f=20){const g=new L,c={v0:0,v1:0};g.addPole(t.fromValues(0,0));for(var a=0;a<f;++a){var b=2*a*Math.PI/f,d=Math.cos(b);const e=Math.sin(b);b=t.fromValues(.5*d,.5*e);d=t.fromValues(d,e);g.addVertex(b,d)}for(a=0;a<f-1;++a)g.addSegment({v0:a,
v1:a+1},c);g.addSegment({v0:f-1,v1:0},c);return g};u.makeFrame=J;u.profileSpaceToVertexSpace=function(f,g,c){f[0]=c[0]*g.right[0]+c[1]*g.up[0];f[1]=c[0]*g.right[1]+c[1]*g.up[1];f[2]=c[0]*g.right[2]+c[1]*g.up[2]};u.vertexSpaceToProfileSpace=function(f,g,c){r.set(f,n.dot(c,g.right),n.dot(c,g.up))};Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});