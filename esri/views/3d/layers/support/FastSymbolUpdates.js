// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/has ../../../../core/mathUtils ../../../../chunks/mat3 ../../../../chunks/mat3f64 ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../renderers/support/lengthUtils ../../support/debugFlags".split(" "),function(f,S,C,H,I,k,y,J,K,D,L){function t(a){return null!==a&&void 0!==a}function q(a){return"number"===typeof a}function v(a){return"string"===typeof a}function g(a,c){a&&a.push(c)}function M(a,c,b,d=y.create()){a=
a||0;c=c||0;b=b||0;0!==a&&k.rotateZ(d,d,-a/180*Math.PI);0!==c&&k.rotateX(d,d,c/180*Math.PI);0!==b&&k.rotateY(d,d,b/180*Math.PI);return d}function n(a,c,b,d,e){const h=a.minSize,w=a.maxSize;if(a.expression)return g(e,"Could not convert size info: expression not supported"),!1;if(a.useSymbolValue)return a=d.symbolSize[b],c.minSize[b]=a,c.maxSize[b]=a,c.offset[b]=c.minSize[b],c.factor[b]=0,c.type[b]=f.FastSizeType.DefinedSize,!0;if(t(a.field)){if(t(a.stops)){if(2===a.stops.length&&q(a.stops[0].size)&&
q(a.stops[1].size))return E(a.stops[0].size,a.stops[1].size,a.stops[0].value,a.stops[1].value,c,b),c.type[b]=f.FastSizeType.DefinedSize,!0;g(e,"Could not convert size info: stops only supported with 2 elements");return!1}if(q(h)&&q(w)&&t(a.minDataValue)&&t(a.maxDataValue))return E(h,w,a.minDataValue,a.maxDataValue,c,b),c.type[b]=f.FastSizeType.DefinedSize,!0;if(null!=D.meterIn[a.valueUnit])return c.minSize[b]=-Infinity,c.maxSize[b]=Infinity,c.offset[b]=0,c.factor[b]=1/D.meterIn[a.valueUnit],c.type[b]=
f.FastSizeType.DefinedSize,!0;if("unknown"===a.valueUnit)return g(e,"Could not convert size info: proportional size not supported"),!1;g(e,"Could not convert size info: scale-dependent size not supported");return!1}if(!t(a.field)){if(a.stops&&a.stops[0]&&q(a.stops[0].size))return c.minSize[b]=a.stops[0].size,c.maxSize[b]=a.stops[0].size,c.offset[b]=c.minSize[b],c.factor[b]=0,c.type[b]=f.FastSizeType.DefinedSize,!0;if(q(h))return c.minSize[b]=h,c.maxSize[b]=h,c.offset[b]=h,c.factor[b]=0,c.type[b]=
f.FastSizeType.DefinedSize,!0}g(e,"Could not convert size info: unsupported variant of sizeInfo");return!1}function E(a,c,b,d,e,h){d=0<Math.abs(d-b)?(c-a)/(d-b):0;e.minSize[h]=0<d?a:c;e.maxSize[h]=0<d?c:a;e.offset[h]=a-b*d;e.factor[h]=d}function N(a,c,b,d){if(a.normalizationField||a.valueRepresentation)return g(d,"Could not convert size info: unsupported property"),null;var e=a.field;if(null!=e&&!v(e))return g(d,"Could not convert size info: field is not a string"),null;if(!c.size)c.size={field:a.field,
minSize:[0,0,0],maxSize:[0,0,0],offset:[0,0,0],factor:[0,0,0],type:[f.FastSizeType.Undefined,f.FastSizeType.Undefined,f.FastSizeType.Undefined]};else if(a.field)if(!c.size.field)c.size.field=a.field;else if(a.field!==c.size.field)return g(d,"Could not convert size info: multiple fields in use"),null;switch(a.axis){case "width":return(e=n(a,c.size,0,b,d))?c:null;case "height":return(e=n(a,c.size,2,b,d))?c:null;case "depth":return(e=n(a,c.size,1,b,d))?c:null;case "width-and-depth":return(e=n(a,c.size,
0,b,d))&&n(a,c.size,1,b,d),e?c:null;case null:case void 0:case "all":return(e=(e=(e=n(a,c.size,0,b,d))&&n(a,c.size,1,b,d))&&n(a,c.size,2,b,d))?c:null;default:return g(d,`Could not convert size info: unknown axis "${a.axis}""`),null}}function O(a,c,b){for(let d=0;3>d;++d){let e=c.unitInMeters;a.type[d]===f.FastSizeType.DefinedSize&&(e*=c.modelSize[d],a.type[d]=f.FastSizeType.DefinedScale);a.minSize[d]/=e;a.maxSize[d]/=e;a.offset[d]/=e;a.factor[d]/=e}if(a.type[0]!==f.FastSizeType.Undefined)c=0;else if(a.type[1]!==
f.FastSizeType.Undefined)c=1;else if(a.type[2]!==f.FastSizeType.Undefined)c=2;else return g(b,"No size axis contains a valid size or scale"),!1;for(b=0;3>b;++b)a.type[b]===f.FastSizeType.Undefined&&(a.minSize[b]=a.minSize[c],a.maxSize[b]=a.maxSize[c],a.offset[b]=a.offset[c],a.factor[b]=a.factor[c],a.type[b]=a.type[c]);return!0}function F(a,c,b){a[4*c]=b.r/255;a[4*c+1]=b.g/255;a[4*c+2]=b.b/255;a[4*c+3]=b.a}function P(a,c,b){if(a.normalizationField)return g(b,"Could not convert color info: unsupported property"),
null;if(v(a.field))if(a.stops){if(8<a.stops.length)return g(b,"Could not convert color info: too many color stops"),null;c.color={field:a.field,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};a=a.stops;for(b=0;8>b;++b){const d=a[Math.min(b,a.length-1)];c.color.values[b]=d.value;F(c.color.colors,b,d.color)}}else return g(b,"Could not convert color info: missing stops or colors"),null;else if(a.stops&&0<=a.stops.length)for(a=a.stops&&0<=a.stops.length&&
a.stops[0].color,c.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},b=0;8>b;b++)c.color.values[b]=Infinity,F(c.color.colors,b,a);else return g(b,"Could not convert color info: no field and no colors/stops"),null;return c}function Q(a,c,b){if(a.normalizationField)return g(b,"Could not convert opacity info: unsupported property"),null;if(v(a.field))if(a.stops){if(8<a.stops.length)return g(b,"Could not convert opacity info: too many opacity stops"),
null;c.opacity={field:a.field,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};a=a.stops;for(b=0;8>b;++b){const d=a[Math.min(b,a.length-1)];c.opacity.values[b]=d.value;c.opacity.opacityValues[b]=d.opacity}}else return g(b,"Could not convert opacity info: missing stops or opacities"),null;else if(a.stops&&0<=a.stops.length)for(a=a.stops&&0<=a.stops.length?a.stops[0].opacity:0,c.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]},b=0;8>b;b++)c.opacity.values[b]=Infinity,
c.opacity.opacityValues[b]=a;else return g(b,"Could not convert opacity info: no field and no opacities/stops"),null;return c}function z(a,c,b){a=2===b&&"arithmetic"===a.rotationType;c.offset[b]=a?90:0;c.factor[b]=a?-1:1;c.type[b]=1}function R(a,c,b){if(!v(a.field))return g(b,"Could not convert rotation info: field is not a string"),null;if(!c.rotation)c.rotation={field:a.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};else if(a.field)if(!c.rotation.field)c.rotation.field=a.field;else if(a.field!==
c.rotation.field)return g(b,"Could not convert rotation info: multiple fields in use"),null;switch(a.axis){case "tilt":return z(a,c.rotation,0),c;case "roll":return z(a,c.rotation,1),c;case null:case void 0:case "heading":return z(a,c.rotation,2),c;default:return g(b,`Could not convert rotation info: unknown axis "${a.axis}""`),null}}function A(a,c,b){if(!a)return null;const d=!c.supportedTypes||!!c.supportedTypes.size,e=!c.supportedTypes||!!c.supportedTypes.color,h=!c.supportedTypes||!!c.supportedTypes.rotation,
w=!!c.supportedTypes&&!!c.supportedTypes.opacity,m=a.reduce((l,r)=>{if(!l)return l;if(r.valueExpression)return g(b,"Could not convert visual variables: arcade expressions not supported"),null;switch(r.type){case "size":return d?N(r,l,c,b):l;case "color":return e?P(r,l,b):l;case "opacity":return w?Q(r,l,b):null;case "rotation":return h?R(r,l,b):l;default:return null}},{size:null,color:null,opacity:null,rotation:null});return 0<a.length&&m&&!m.size&&!m.color&&!m.opacity&&!m.rotation||m&&m.size&&!O(m.size,
c,b)?null:m}function x(a,c,b){if(!!a!==!!c||a&&a.field!==c.field)return!1;if(a&&"rotation"===b)for(b=0;3>b;b++)if(a.type[b]!==c.type[b]||a.offset[b]!==c.offset[b]||a.factor[b]!==c.factor[b])return!1;return!0}function B(a,c){const b={vvSizeEnabled:!1,vvSizeMinSize:null,vvSizeMaxSize:null,vvSizeOffset:null,vvSizeFactor:null,vvSizeValue:null,vvColorEnabled:!1,vvColorValues:null,vvColorColors:null,vvOpacityEnabled:!1,vvOpacityValues:null,vvOpacityOpacities:null,vvSymbolAnchor:null,vvSymbolRotationMatrix:null},
d=a&&null!=a.size;a&&a.size?(b.vvSizeEnabled=!0,b.vvSizeMinSize=a.size.minSize,b.vvSizeMaxSize=a.size.maxSize,b.vvSizeOffset=a.size.offset,b.vvSizeFactor=a.size.factor):a&&d&&(b.vvSizeValue=c.transformation.scale);a&&d&&(b.vvSymbolAnchor=c.transformation.anchor,b.vvSymbolRotationMatrix=I.create(),k.identity(u),M(c.transformation.rotation[2],c.transformation.rotation[0],c.transformation.rotation[1],u),H.fromMat4(b.vvSymbolRotationMatrix,u));a&&a.color&&(b.vvColorEnabled=!0,b.vvColorValues=a.color.values,
b.vvColorColors=a.color.colors);a&&a.opacity&&(b.vvOpacityEnabled=!0,b.vvOpacityValues=a.opacity.values,b.vvOpacityOpacities=a.opacity.opacityValues);return b}f.FastSizeType=void 0;(function(a){a[a.Undefined=0]="Undefined";a[a.DefinedSize=1]="DefinedSize";a[a.DefinedScale=2]="DefinedScale"})(f.FastSizeType||(f.FastSizeType={}));f.FastRotationType=void 0;(function(a){a[a.Undefined=0]="Undefined";a[a.DefinedAngle=1]="DefinedAngle"})(f.FastRotationType||(f.FastRotationType={}));const p=y.create(),G=
K.create(),u=y.create();f.convertVisualVariables=A;f.evaluateModelTransform=function(a,c,b){if(!a.vvSizeEnabled)return b;k.copy(p,b);b=a.vvSymbolRotationMatrix;k.set(u,b[0],b[1],b[2],0,b[3],b[4],b[5],0,b[6],b[7],b[8],0,0,0,0,1);k.multiply(p,p,u);for(b=0;3>b;++b)G[b]=C.clamp(a.vvSizeOffset[b]+c[0]*a.vvSizeFactor[b],a.vvSizeMinSize[b],a.vvSizeMaxSize[b]);k.scale(p,p,G);k.translate(p,p,a.vvSymbolAnchor);return p};f.evaluateModelTransformScale=function(a,c,b){if(!c.vvSizeEnabled)return J.set(a,1,1,1);
for(let d=0;3>d;++d)a[d]=C.clamp(c.vvSizeOffset[d]+b[0]*c.vvSizeFactor[d],c.vvSizeMinSize[d],c.vvSizeMaxSize[d]);return a};f.getMaterialParameters=B;f.initFastSymbolUpdatesState=function(a,c){return!a||L.TESTS_DISABLE_FAST_UPDATES?{enabled:!1}:(a=A(a.visualVariables,c))?{enabled:!0,visualVariables:a,materialParameters:B(a,c),requiresShaderTransformation:a&&null!=a.size}:{enabled:!1}};f.updateFastSymbolUpdatesState=function(a,c,b){if(!c||!a.enabled)return!1;const d=a.visualVariables;c=A(c.visualVariables,
b);if(!(c&&x(d.size,c.size,"size")&&x(d.color,c.color,"color")&&x(d.rotation,c.rotation,"rotation")&&x(d.opacity,c.opacity,"opacity")))return!1;a.visualVariables=c;a.materialParameters=B(c,b);a.requiresShaderTransformation=c&&null!=c.size;return!0};Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});