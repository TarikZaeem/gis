// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./PatchGeometryFactory ./terrainUtils ./Tile ./tileUtils ../webgl-engine/lib/DoubleArray".split(" "),function(ha,ia,ja,f,n,pa,ea,qa,L,fa,y,T,ra,sa){function ka(D,G,p,b,a,d){D=b-D;G=a-G;p=d-p;return D*D+G*G+p*p}let ua=function(D){function G(b,a,d){var e=D.call(this)||this;e._convexHull=
Array(24);e._boundingSphere=qa.create();void 0!==b&&e.init(b,a,d);return e}ia._inheritsLoose(G,D);var p=G.prototype;p.init=function(b,a,d){D.prototype.init.call(this,b,a,d);a=this.ellipsoid.radius;d=this.extentInRadians[0];const e=this.extentInRadians[1],c=this.extentInRadians[2],g=this.extentInRadians[3];b=b[0];const v=ja.lerp(e,g,.5),m=ja.lerp(d,c,.5);this._edgeLen=(c-d)*Math.cos(0===b?0:Math.min(Math.abs(e),Math.abs(g)))*a;this._edgeLen2=this._edgeLen*this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*
a-this._edgeLen2/4);pa.lonLatToSphericalPCPF(this.centerAtSeaLevel,m,v,this.ellipsoid.radius);a=n.fromArray(this.centerAtSeaLevel);f.normalize(a,a);this.up=a;this.updateRadiusAndCenter()};p.updateRadiusAndCenter=function(){this._updateBoundingVolumes();const b=this._center;if(0===this.lij[0])f.set(b[T.CenterPosition.MIDDLE],0,0,0),f.set(b[T.CenterPosition.TOP],0,0,0),f.set(b[T.CenterPosition.BOTTOM],0,0,0),b[T.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();
const g=b[T.CenterPosition.MIDDLE],v=this.convexHull;var a=0;for(let m=0;8>m;++m){var d=Math,e=d.max;var c=3*m;c=ka(g[0],g[1],g[2],v[c+0],v[c+1],v[c+2]);a=e.call(d,a,c)}b[T.CenterPosition.MIDDLE][3]=Math.sqrt(a)}};p._calculateFrustumVisibilityStatus=function(b){if(!ea.intersectsSphere(b,this._boundingSphere))return L.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return L.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,d=this.surface.view.state.camera.near;let e=!0;for(let g=0;g<ea.NumPlanes.NUM;g++){var c=
b[g];const v=c[0],m=c[1],E=c[2];c=c[3]-(g===ea.PlaneIndex.NEAR?d:0);let H=!1;for(let M=0;8>M;++M){const w=3*M;if(0>v*a[w+0]+m*a[w+1]+E*a[w+2]+c){if(H=!0,!e)break}else e=!1}if(!H)return L.TileFrustumVisibility.OUTSIDE}return e?L.TileFrustumVisibility.INSIDE:L.TileFrustumVisibility.INTERSECTS};p.computeElevationBounds=function(){D.prototype.computeElevationBounds.call(this);this._updateBoundingVolumes()};p.createGeometry=function(){fa.createSphericalGlobePatch(this.renderData,this._getPatchType());
this._updateBoundingVolumes();this.setMemoryDirty()};p._updateBoundingVolumes=function(){this._updateConvexHull();this._updateBoundingSphere();y.ENABLE_TERRAIN_INTERNAL_CHECKS&&this._checkBVs()};p._updateBoundingSphere=function(){const b=this._boundingSphere;var a=this.elevationBounds,d=this.ellipsoid.radius,e=a[1];if(0===this.level)f.set(b,0,0,0),b[3]=d+e;else{e=this.extentInRadians;var c=.5*(e[0]+e[2]),g=e[3];O(la,c,e[1],d);O(ma,c,g,d);f.add(b,la,ma);f.scale(b,b,(d+.5*(a[0]+a[1]))/f.len(b));a=this.convexHull;
d=0;for(e=0;8>e;++e){c=b[0]-a[3*e];g=b[1]-a[3*e+1];const v=b[2]-a[3*e+2];d=Math.max(d,Math.sqrt(c*c+g*g+v*v))}b[3]=d+2}};p._updateConvexHull=function(){var b=this.extentInRadians,a=this.ellipsoid.radius;if(0!==this.level){var d=this.elevationBounds,e=this._getPatchType(),c=this.surface.isWebMercator,g=c&&e===L.PatchType.HAS_NORTH_POLE,v=(e=c&&e===L.PatchType.HAS_SOUTH_POLE)||g;c=Math.PI/2;var m=b[0],E=b[2];e=e?-c:b[1];var H=g?c:b[3],M=.5*(m+E);b=d[0];var w=a+(v?Math.min(0,b-1):b);b=n.create();g=n.create();
c=n.create();var N=n.create();O(b,m,e,w);O(g,m,H,w);O(c,E,H,w);O(N,E,e,w);m=(F,r)=>{for(let I=0;3>I;++I)this._convexHull[3*r+I]=F[I]};m(b,0);m(g,1);m(c,2);m(N,3);d=d[1];var ba=a+(v?Math.max(0,d+1):d),h=n.create();a=n.create();d=n.create();O(a,M,H,w);O(d,M,e,w);f.add(h,a,d);f.normalize(h,h);var t=n.create(),z=n.create();e=(F,r)=>{f.sub(z,F,r);f.normalize(z,z);r=-f.dot(F,t)/f.dot(z,t);y.internalAssert(0<=r);f.scale(z,z,r);f.add(F,F,z)};2**this.lij[0]>2*this.lij[1]?(a=n.create(),f.cross(a,na,d),f.normalize(a,
a),f.cross(t,d,a),f.normalize(t,t),y.internalAssert(y.almostEquals(f.dot(t,d)/f.len(d),0)),e(b,g),e(N,c),m(b,0),m(N,3)):2**this.lij[0]!==2*this.lij[1]&&(d=n.create(),f.cross(d,na,a),f.normalize(d,d),f.cross(t,d,a),f.normalize(t,t),e(g,b),e(c,N),m(g,1),m(c,2));a=(F,r)=>{const I=ba/f.dot(r,h);for(let P=0;3>P;++P)this._convexHull[3*F+P]=r[P]*I};a(4,b);a(5,g);a(6,c);a(7,N)}};p._getPatchType=function(){const b=this.lij[1],a=b===(1<<this.level)-1;return 0===b?a?L.PatchType.HAS_BOTH_POLES:L.PatchType.HAS_NORTH_POLE:
a?L.PatchType.HAS_SOUTH_POLE:L.PatchType.REGULAR};p.intersectsRay=function(b,a,d,e){var c=this._boundingSphere;d=c[3]+d;var g=c[0]-b[0];e=c[1]-b[1];b=c[2]-b[2];c=(g*a[0]+e*a[1]+b*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);g=a[0]*c-g;e=a[1]*c-e;a=a[2]*c-b;return g*g+e*e+a*a<d*d};p.getDefaultVerticesPerSide=function(){return this.level<oa.length?oa[this.level]+1:2};p.updateCornerElevations=function(){fa.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()};p.updateEdgeElevations=function(){fa.updateEdgesAndCornersSpherical(this.renderData);
this._updateBoundingVolumes()};p._checkBVs=function(){if(y.ENABLE_TERRAIN_INTERNAL_CHECKS&&!(2>=this.level)){var b=this._boundingSphere,a=b[3],d=n.create(),e=this.ellipsoid.radius,c=this.elevationBounds;c[1]-c[0];var g=e+c[0],v=this._center[T.CenterPosition.MIDDLE][3],m=this.convexHull,E=(k,u)=>{for(let q=0;3>q;++q)k[q]=m[3*u+q]},H=n.create(),M=n.create(),w=n.create(),N=n.create(),ba=n.create(),h=(k,u,q,U)=>{E(M,k);E(w,u);E(N,q);f.sub(M,M,w);f.sub(N,N,w);f.cross(H,M,N);f.normalize(H,H);var ca=f.dot(H,
w);E(ba,U);const ta=f.dot(H,ba);ca=Math.abs(ta-ca);y.internalAssert(y.almostEquals(ca,0),`Non coplanar ${k},${u},${q},${U} diff = ${ca}`)};h(0,1,2,3);h(4,5,6,7);h(0,1,4,5);h(1,2,5,6);h(2,3,6,7);h(3,0,7,4);var t=sa.newDoubleArray(24),z=n.create(),F=n.create(),r=n.create(),I=n.create();h=(k,u,q,U)=>{E(z,u);E(F,q);E(r,U);f.sub(z,z,F);f.normalize(z,z);f.sub(r,r,F);f.normalize(r,r);f.cross(I,z,r);f.normalize(I,I);u=f.dot(I,F);k*=4;for(q=0;3>q;++q)t[k+q]=I[q];t[k+3]=u};h(0,0,1,2);h(1,1,0,4);h(2,1,5,2);
h(3,3,2,6);h(4,4,0,3);h(5,4,6,5);var P=(k,u,q,U)=>{k*=4;return t[k+0]*u+t[k+1]*q+t[k+2]*U-t[k+3]},A=(k,u,q,U)=>-1<=P(k,u,q,U),B=2**this.lij[0]>2*this.lij[1];h=(k,u,q)=>Math.sqrt(ka(k,u,q,b[0],b[1],b[2]))<a;var l=this.extentInRadians,x=.5*(l[0]+l[2]),C=l[1],Q=l[3];l=n.create();var R=n.create();O(l,x,Q,g);O(R,x,C,g);g=B?"Upper":"Lower";B=!0;for(x=0;6>x;++x){for(C=0;8>C;++C)Q=3*C,Q=-1<=P(x,m[Q+0],m[Q+1],m[Q+2]),B&&(B=Q),y.internalAssert(Q,`Tile[${this.lij}] Convex hull point ${C} outside of plane ${x}`);
y.internalAssert(A(x,R[0],R[1],R[2]),`Tile[${this.lij}] (${g}) bottom mid outside of plane ${x}`);y.internalAssert(A(x,l[0],l[1],l[2]),`Tile[${this.lij}] (${g}) top mid outside of plane ${x}`)}y.internalAssert(B,"Not all convex hull points are inside  convex hull polyhedron");y.internalAssert(h(R[0],R[1],R[2]),`Tile[${this.lij}] (${g}) bottom mid outside of bounding sphere`);y.internalAssert(h(l[0],l[1],l[2]),`Tile[${this.lij}] (${g}) top mid outside of bounding sphere`);for(A=0;8>A;++A)l=3*A,l=h(m[l+
0],m[l+1],m[l+2]),y.internalAssert(l,`Tile[${this.lij}] Convex hull point ${A} outside of bounding sphere`);for(h=0;6>h;++h)for(A=0;8>A;++A)l=3*A,-1<=P(h,m[l+0],m[l+1],m[l+2])||console.error(`Tile[${this.lij}] Convex hull point ${A} outside of plane ${h}`);h=this.extentInRadians;h=Math.round(Math.max(h[2]-h[0],h[3]-h[1])*e);if(C=this.renderData)if(B=C.geometryInfo,R=C.localOrigin,g=B.vertexAttributes?.position){A=g.count;l=n.create();B=B.numVerticesPerSide-2;x=B*B;C=C.geometryState.neighborData;Q=
C.edgeResolutions.reduce((k,u)=>k+u+1,0);for(let k=0;k<A;++k){var W=k<x,X=!W&&k<x+Q,Z=!1,Y=-1;if(X){var J=x;for(var S=0;4>S;++S){var K=C.edgeResolutions[S];if(k===J||k===J+K-1){Z=!0;break}J+=K;if(k<J){Y=S;break}}}J=Y;Y=X&&!Z;J=X?C.edgePeerNeighbors[J]:null;S=X&&J&&0<ra.compareTilesByLij(this,J);var V=W?"internal":Y?"edge":Z?"corner":"pole";g.getVec(k,d);f.add(l,d,R);W=f.len(l)-e;X=0;Z=!1;Y=c[0]-W;J=W-c[1];var aa=1<Y,da=1<J;K=aa||da;S=`Tile[${this.lij}].vertex[${k}]:${V}`+(aa?"(below)":da?"(above)":
"")+(S?"(Neighbor)":"");V=f.dist(l,b);V>=a+0&&(V-=a,K||(console.error(`${S} is out of the bounding sphere by ${V.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${W.toFixed(0)} / [${c[0].toFixed(0)}..${c[1].toFixed(0)}] (${(V/a).toFixed(0)})`),Z=!0));for(K=0;6>K;++K)-1<=P(K,l[0],l[1],l[2])||(V=P(K,l[0],l[1],l[2]),aa=k%B,da=(k-aa)/B,0===K&&Y||5===K&&J||(console.error(`${S} (${aa},${da})|${B}] is out of the bounding trapezoid plane ${K}`+` h=${Math.round(W)} / [${Math.round(c[0])}..${Math.round(c[1])}] dist=${Math.round(V)}`+
` radii = ${Math.round(a)}/${Math.round(v)}} : maxL = ${h}`),++X));if(Z||0<X)break}}}};ia._createClass(G,[{key:"convexHull",get:function(){return this._convexHull}}]);return G}(T.Tile);const oa=[128,64,64,32,16,8,8,4],O=(D,G,p,b)=>{const a=Math.sin(G),d=Math.cos(p);p=Math.sin(p);D[0]=b*d*Math.cos(G);D[1]=b*d*a;D[2]=b*p},na=[0,0,1],la=n.create(),ma=n.create();ha.SphericalPatch=ua;Object.defineProperty(ha,Symbol.toStringTag,{value:"Module"})});