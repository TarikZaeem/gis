// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/mathUtils ../../core/maybe ./checkWebGLError ./context-util ./enums".split(" "),function(F,I,B,G,v,y,z,e){function A(f){return v.isSome(f)&&"type"in f&&"compressed"===f.type}function C(f){var n;if(n=v.isSome(f)&&!A(f))n=!(v.isSome(f)&&"byteLength"in f);return n}function w(f){return f===e.TextureType.TEXTURE_3D||f===e.TextureType.TEXTURE_2D_ARRAY}function H(f,n,a,b=1){n=Math.max(n,a);f===e.TextureType.TEXTURE_3D&&(n=Math.max(n,
b));return Math.round(Math.log(n)/Math.LN2)+1}const D={target:e.TextureType.TEXTURE_2D,samplingMode:e.TextureSamplingMode.LINEAR,wrapMode:e.TextureWrapMode.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,preMultiplyAlpha:!1,isImmutable:!1};B=function(){function f(a,b,d=null){this._context=a;this.type="texture";this._glName=null;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;a.instanceCounter.increment(e.ResourceType.Texture,this);this._descriptor={...D,...b};
for(const c in D)void 0===this._descriptor[c]&&(this._descriptor[c]=D[c]);if(a.type!==z.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),w(this._descriptor.target)))throw Error("3D and array textures are not supported in WebGL1");this._descriptor.target===e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(d):this.setData(d)}var n=f.prototype;n.dispose=function(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),
this._glName=null,this._context.instanceCounter.decrement(e.ResourceType.Texture,this))};n.release=function(){this.dispose()};n.resize=function(a,b){const d=this._descriptor;if(d.width!==a||d.height!==b){if(this._wasImmutablyAllocated)throw Error("Immutable textures can't be resized!");d.width=a;d.height=b;this._descriptor.target===e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}};n._setDataCubeMap=function(a=null){for(let b=e.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;b<=
e.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;b++)this._setData(a,b)};n.setData=function(a){this._setData(a)};n._setData=function(a,b){if(this._context&&this._context.gl){var d=this._context.gl;this._glName||(this._glName=d.createTexture());void 0===a&&(a=null);var c=this._descriptor,g=b??c.target,k=w(g);null===a&&(c.width=c.width||4,c.height=c.height||4,k&&(c.depth=c.depth??1));b=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);f._validateTexture(this._context,
c);this._configurePixelStorage();y.checkWebGLError(d);var h=c.pixelFormat,l=c.internalFormat??this._deriveInternalFormat(h,c.dataType);if(C(a)){h=a.width;let m=a.height;a instanceof HTMLVideoElement&&(h=a.videoWidth,m=a.videoHeight);c.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(g,l,c.hasMipmap,h,m,1);this._texImage(g,0,l,h,m,1,a);y.checkWebGLError(d);c.hasMipmap&&this.generateMipmap();void 0===c.width&&(c.width=h);void 0===c.height&&(c.height=m);k&&void 0===c.depth&&(c.depth=1)}else{const {width:m,
height:p,depth:q}=c;if(null==m||null==p)throw Error("Width and height must be specified!");if(k&&null==q)throw Error("Depth must be specified!");c.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(g,l,c.hasMipmap,m,p,q);d.DEPTH24_STENCIL8&&l===d.DEPTH_STENCIL&&(l=d.DEPTH24_STENCIL8);if(A(a)){const r=a.levels;a=H(g,m,p,q);k=Math.min(a-1,r.length-1);v.isSome(this._context.gl2)?d.texParameteri(c.target,this._context.gl2.TEXTURE_MAX_LEVEL,k):c.hasMipmap=c.hasMipmap&&a===r.length;const u=l;if(!(u in
e.CompressedTextureFormat))throw Error("Attempting to use compressed data with an umcompressed format!");this._forEachMipmapLevel((t,x,E,J)=>{this._compressedTexImage(g,t,u,x,E,J,r[Math.min(t,r.length-1)])},k)}else v.isSome(a)?(this._texImage(g,0,l,m,p,q,a),y.checkWebGLError(d),c.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((r,u,t,x)=>{this._texImage(g,r,l,u,t,x,null);y.checkWebGLError(d)})}f._applySamplingMode(d,this._descriptor);f._applyWrapMode(d,this._descriptor);f._applyAnisotropicFilteringParameters(this._context,
this._descriptor);y.checkWebGLError(d);this._context.bindTexture(b,f.TEXTURE_UNIT_FOR_UPDATES)}};n.updateData=function(a,b,d,c,g,k,h=0){k||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const l=this._context.gl,m=this._descriptor,{pixelFormat:p,dataType:q,target:r,isImmutable:u}=m,t=m.internalFormat??this._deriveInternalFormat(p,q);if(u&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");
const x=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES,!0);(0>b||0>d||c>m.width||g>m.height||b+c>m.width||d+g>m.height)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();if(h){if(v.isNone(this._context.gl2)){console.error("Webgl2 must be enabled to use dataRowOffset!");return}l.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,h)}C(k)?v.isSome(this._context.gl2)?this._context.gl2.texSubImage2D(r,a,b,d,c,g,p,q,k):l.texSubImage2D(r,a,b,d,p,q,
k):A(k)?l.compressedTexSubImage2D(r,a,b,d,c,g,t,k.levels[a]):l.texSubImage2D(r,a,b,d,c,g,p,q,k);if(h){if(v.isNone(this._context.gl2)){console.error("Webgl2 must be enabled to use dataRowOffset!");return}l.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS,0)}this._context.bindTexture(x,f.TEXTURE_UNIT_FOR_UPDATES)};n.updateData3D=function(a,b,d,c,g,k,h,l){l||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const m=this._context.gl2;
if(v.isNone(m))throw Error("3D textures are not supported in WebGL1");const p=this._descriptor,{pixelFormat:q,dataType:r,isImmutable:u,target:t}=p,x=p.internalFormat??this._deriveInternalFormat(q,r);if(u&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");w(t)||console.warn("Attempting to set 3D texture data on a non-3D texture");const E=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);
(0>b||0>d||0>c||g>p.width||k>p.height||h>p.depth||b+g>p.width||d+k>p.height||c+h>p.depth)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();A(l)?(l=l.levels[a],m.compressedTexSubImage3D(t,a,b,d,c,g,k,h,x,l)):m.texSubImage3D(t,a,b,d,c,g,k,h,q,r,l);this._context.bindTexture(E,f.TEXTURE_UNIT_FOR_UPDATES)};n.generateMipmap=function(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw Error("Cannot add mipmaps to immutable texture after allocation");
this._samplingModeDirty=a.hasMipmap=!0;f._validateTexture(this._context,a)}a.samplingMode===e.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,a.samplingMode=e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===e.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const b=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);this._context.gl.generateMipmap(a.target);
this._context.bindTexture(b,f.TEXTURE_UNIT_FOR_UPDATES)};n.setSamplingMode=function(a){a!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=a,this._samplingModeDirty=!0)};n.setWrapMode=function(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,f._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)};n.applyChanges=function(){const a=this._context.gl,b=this._descriptor;this._samplingModeDirty&&(f._applySamplingMode(a,b),this._samplingModeDirty=!1);this._wrapModeDirty&&
(f._applyWrapMode(a,b),this._wrapModeDirty=!1)};n._deriveInternalFormat=function(a,b){if(this._context.type===z.ContextType.WEBGL1)return a;switch(b){case e.PixelType.FLOAT:switch(a){case e.PixelFormat.RGBA:return e.SizedPixelFormat.RGBA32F;case e.PixelFormat.RGB:return e.SizedPixelFormat.RGB32F;default:throw Error("Unable to derive format");}case e.PixelType.UNSIGNED_BYTE:switch(a){case e.PixelFormat.RGBA:return e.SizedPixelFormat.RGBA8;case e.PixelFormat.RGB:return e.SizedPixelFormat.RGB8}default:return a}};
n._configurePixelStorage=function(){const a=this._context.gl,{unpackAlignment:b,flipped:d,preMultiplyAlpha:c}=this._descriptor;a.pixelStorei(a.UNPACK_ALIGNMENT,b);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,d?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,c?1:0)};n._texStorage=function(a,b,d,c,g,k){const h=this._context.gl2;if(v.isNone(h))throw Error("Immutable textures are not supported in WebGL1");if(!(b in e.SizedPixelFormat))throw Error("Immutable textures must have a sized internal format");if(this._descriptor.isImmutable){d=
d?H(a,c,g,k):1;if(w(a)){if(null==k)throw Error("Missing depth dimension for 3D texture upload");h.texStorage3D(a,d,b,c,g,k)}else h.texStorage2D(a,d,b,c,g);this._wasImmutablyAllocated=!0}};n._texImage=function(a,b,d,c,g,k,h){const l=this._context.gl;let m=null;const p=this._context.type===z.ContextType.WEBGL2,q=w(a),{isImmutable:r,pixelFormat:u,dataType:t}=this._descriptor;p&&(m=l);if(!p&&C(h))l.texImage2D(a,0,d,u,t,h);else if(r){if(v.isSome(h))if(q){if(null==k)throw Error("Missing depth dimension for 3D texture upload");
m.texSubImage3D(a,b,0,0,0,c,g,k,u,t,h)}else l.texSubImage2D(a,b,0,0,c,g,u,t,h)}else if(h=v.unwrap(h),q){if(null==k)throw Error("Missing depth dimension for 3D texture upload");m.texImage3D(a,b,d,c,g,k,0,u,t,h)}else l.texImage2D(a,b,d,c,g,0,u,t,h)};n._compressedTexImage=function(a,b,d,c,g,k,h){const l=this._context.gl;let m=null;const p=w(a),q=this._descriptor.isImmutable;if(p){if(this._context.type!==z.ContextType.WEBGL2)throw Error("3D textures are not supported in WebGL1");m=l}if(q){if(v.isSome(h))if(p){if(null==
k)throw Error("Missing depth dimension for 3D texture upload");m.compressedTexSubImage3D(a,b,0,0,0,c,g,k,d,h)}else l.compressedTexSubImage2D(a,b,0,0,c,g,d,h)}else if(p){if(null==k)throw Error("Missing depth dimension for 3D texture upload");m.compressedTexImage3D(a,b,d,c,g,k,0,h)}else l.compressedTexImage2D(a,b,d,c,g,0,h)};n._forEachMipmapLevel=function(a,b=Infinity){let {width:d,height:c,depth:g,hasMipmap:k,target:h}=this._descriptor;const l=h===e.TextureType.TEXTURE_3D;if(null==d||null==c||l&&null==
g)throw Error("Missing texture dimensions for mipmap calculation");for(let m=0;;++m){a(m,d,c,g);if(!k||1===d&&1===c&&(!l||1===g)||m>=b)break;d=Math.max(1,d>>1);c=Math.max(1,c>>1);l&&(g=Math.max(1,g>>1))}};f._validateTexture=function(a,b){(null!=b.width&&0>b.width||null!=b.height&&0>b.height||null!=b.depth&&0>b.depth)&&console.error("Negative dimension parameters are not allowed!");a=a.type===z.ContextType.WEBGL2;const d=null!=b.width&&G.isPowerOfTwo(b.width)&&null!=b.height&&G.isPowerOfTwo(b.height);
a||!b.isImmutable&&!w(b.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!");a||d||("number"===typeof b.wrapMode?b.wrapMode!==e.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(b.wrapMode.s!==e.TextureWrapMode.CLAMP_TO_EDGE||b.wrapMode.t!==e.TextureWrapMode.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),b.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))};
f._applySamplingMode=function(a,b){let d=b.samplingMode,c=b.samplingMode;if(d===e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||d===e.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)d=e.TextureSamplingMode.LINEAR,b.hasMipmap||(c=e.TextureSamplingMode.LINEAR);else if(d===e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||d===e.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)d=e.TextureSamplingMode.NEAREST,b.hasMipmap||(c=e.TextureSamplingMode.NEAREST);a.texParameteri(b.target,a.TEXTURE_MAG_FILTER,d);a.texParameteri(b.target,
a.TEXTURE_MIN_FILTER,c)};f._applyWrapMode=function(a,b){"number"===typeof b.wrapMode?(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode)):(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode.s),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode.t))};f._applyAnisotropicFilteringParameters=function(a,b){const d=a.capabilities.textureFilterAnisotropic;d&&a.gl.texParameterf(b.target,d.TEXTURE_MAX_ANISOTROPY,b.maxAnisotropy??1)};I._createClass(f,
[{key:"glName",get:function(){return this._glName}},{key:"descriptor",get:function(){return this._descriptor}},{key:"isDirty",get:function(){return this._samplingModeDirty||this._wrapModeDirty}}]);return f}();B.TEXTURE_UNIT_FOR_UPDATES=0;F.Texture=B;Object.defineProperty(F,Symbol.toStringTag,{value:"Module"})});