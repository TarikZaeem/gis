// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ./enums ./MemoryRequirements ./TileBufferData ./TileDisplayData ./Utils ./WGLDisplayRecord ./cpuMapped/DisplayRecordReader ./mesh/VertexBuffer ./mesh/VertexVector ./util/Writer".split(" "),function(y,B,C,u,x,z,v,A,D,E,F,G){const w=new u,n=new u;u=function(){function l(){this.tileBufferData=this.tileDisplayData=null}var t=l.prototype;t.reshuffle=function(){w.reset();if(this.tileDisplayData){var b=[[],[],[],[],[]],c=this.tileDisplayData.displayObjects;for(var a of c)for(var d of a.displayRecords)b[d.geometryType].push(d);
for(var f of b)for(var g of f)g&&w.needMore(g.geometryType,g.meshData?g.meshData.vertexCount:g.vertexCount,g.meshData?g.meshData.indexData.length:g.indexCount);c=b.length;a=new x;for(d=0;d<c;++d)if(a.geometries[d].indexBuffer=new Uint32Array(Math.round(1.5*w.indicesFor(d))),g=[],f=this.tileBufferData?.geometries[d].vertexBuffer){for(var e in f)g.push(f[e].stride);g=l._computeVertexAlignment(g);var h=Math.round(1.5*w.verticesFor(d));g=l._align(h,g);for(var m in f)h=f[m].stride,a.geometries[d].vertexBuffer[m]=
{stride:h,data:v.allocateTypedArrayBuffer(g,h)}}n.reset();this.tileDisplayData.displayList?.clear();for(e=0;e<c;++e){m=b[e];for(const k of m){if(k.meshData)k.writeMeshDataToBuffers(n.verticesFor(e),a.geometries[e].vertexBuffer,n.indicesFor(e),a.geometries[e].indexBuffer),k.meshData=null;else if(d=this.tileBufferData?.geometries[e]){m=d.vertexBuffer;d=d.indexBuffer;f=a.geometries[e].vertexBuffer;g=a.geometries[e].indexBuffer;h=n.verticesFor(e);const p=n.indicesFor(e);v.copyMeshData(h,p,f,g,k,m,d);
k.vertexFrom=h;k.indexFrom=p}n.needMore(e,k.vertexCount,k.indexCount)}}var {displayList:q,displayObjects:r}=this.tileDisplayData;if(q)for(const k of r)q.addToList(k.displayRecords);this.tileBufferData=a}};t.getStrides=function(){const b=[],c=this.tileBufferData?.geometries;if(!c)return b;for(let a=0;a<c.length;++a){const d=c[a];b[a]={};for(const f in d.vertexBuffer)b[a][f]=d.vertexBuffer[f].stride}return b};t.clone=function(){const b=new l;b.tileBufferData=this.tileBufferData?.clone()??null;b.tileDisplayData=
this.tileDisplayData?.clone()??null;return b};t._guessSize=function(){const b=this.tileDisplayData?.displayObjects??[],c=Math.min(b.length,4);let a=0;for(let d=0;d<c;d++)a=Math.max(a,b[d].displayRecords.length);return 2*(12*b.length+b.length*a*40)};t.serialize=function(){const b=this.tileBufferData.serialize(),c=this.tileBufferData.getBuffers(),a=this.tileDisplayData.serialize(new G(Int32Array,this._guessSize())).buffer();c.push(a);return{result:{displayData:a,bufferData:b},transferList:c}};l.fromVertexData=
function(b,c){const a={},d=new Map;for(const f of c)d.set(f.id,f);v.forEachGeometryType(f=>{const g=b.data[f];if(B.isSome(g)){const h=D.DisplayRecordReader.from(g.records).getCursor();for(;h.next();){var e=h.id;const m=h.materialKey,q=h.indexFrom,r=h.indexCount,k=h.vertexFrom,p=h.vertexCount,H=d.get(e);e=new A(e,f,m);e.indexFrom=q;e.indexCount=r;e.vertexFrom=k;e.vertexCount=p;H.displayRecords.push(e)}a[f]=E.VertexBuffers.fromVertexData(g,f)}else a[f]=(new F.VertexVectors(f,0,C.WGLSymbologyType.DEFAULT)).intoBuffers()});
return l.fromMeshData({displayObjects:c,vertexBuffersMap:a})};l.fromMeshData=function(b){const c=new l,a=new z,d=new x;a.displayObjects=b.displayObjects;for(const f in b.vertexBuffersMap){const g=b.vertexBuffersMap[f];d.geometries[f].indexBuffer=g.indexBuffer;d.geometries[f].vertexBuffer=g.namedBuffers}c.tileDisplayData=a;c.tileBufferData=d;return c};l.bind=function(b,c){const a=new l;a.tileDisplayData=b;a.tileBufferData=c;return a};l.create=function(b,c){const a=new l;a.tileDisplayData=new z;a.tileDisplayData.displayObjects=
b;const d=[0,0,0,0,0],f=[0,0,0,0,0],g=[[],[],[],[],[]];for(var e of b)for(var h of e.displayRecords)g[h.geometryType].push(h),d[h.geometryType]+=h.meshData.vertexCount,f[h.geometryType]+=h.meshData.indexData.length;b=new x;c=[c.fill||{},c.line||{},c.icon||{},c.text||{},c.label||{}];for(e=0;5>e;e++){h=new Uint32Array(f[e]);var m=c[e],q=d[e];const r={};for(const k in m){const p={data:v.allocateTypedArrayBuffer(q,m[k]),stride:m[k]};r[k]=p}m=r;A.writeAllMeshDataToBuffers(g[e],m,h);b.geometries[e]={indexBuffer:h,
vertexBuffer:m}}a.tileBufferData=b;return a};l._align=function(b,c){const a=b%c;return 0===a?b:b+(c-a)};l._computeVertexAlignment=function(b){let c=!1,a=!1;for(const d of b)2===d%4?c=!0:0!==d%4&&(a=!0);return a?4:c?2:1};return l}();y.TileData=u;Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});