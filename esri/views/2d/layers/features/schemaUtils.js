// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.26/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/Error ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../core/screenUtils ../../../../core/sql ../../../../core/accessorSupport/diffUtils ../../../../layers/support/labelingInfo ../../engine/webgl/enums ../../engine/webgl/Utils ../../engine/webgl/techniques/utils ../../engine/webgl/util/vvFlagUtils ./createSymbolSchema ./support/pixelBuffering ./support/rendererUtils ../support/clusterUtils ../support/util".split(" "),function(u,n,V,W,
l,J,X,Y,K,q,Z,aa,L,p,ba,E,M,N){function C(a,b){let c=0,d=0,e=q.WGLSymbologyType.DEFAULT;if(l.isSome(a)){d=ba.getPtMaxVVSize(a,b);"visualVariables"in a&&(c=L.getVVFlags(a.visualVariables||[]),"dot-density"===a.type&&(e=q.WGLSymbologyType.DOT_DENSITY));"heatmap"===a.type&&(e=q.WGLSymbologyType.HEATMAP);if("dictionary"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:q.WGLSymbologyType.DEFAULT};if("pie-chart"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:q.WGLSymbologyType.PIE_CHART};if(e!==
q.WGLSymbologyType.DOT_DENSITY&&e!==q.WGLSymbologyType.HEATMAP){var f=a.getSymbols();"backgroundFillSymbol"in a&&a.backgroundFillSymbol&&f.push(a.backgroundFillSymbol);b=a=!0;for(const g of f)if("cim"===g.type&&(b=!1),"simple-fill"===g.type||"picture-fill"===g.type){f=(f=g.outline)&&"none"!==f.style&&"solid"!==f.style;var h="simple-fill"===g.type&&"none"!==g.style&&"solid"!==g.style;h="picture-fill"===g.type||h||f;f&&(a=!1);h&&(b=!1)}a?e=b?q.WGLSymbologyType.OUTLINE_FILL_SIMPLE:q.WGLSymbologyType.OUTLINE_FILL:
b&&(e=q.WGLSymbologyType.SIMPLE)}}return{vvFlags:c,maxVVSize:d,symbologyType:e}}function O(a,b=!1){try{const d=ca(a,b);var c="heatmap"===a.renderer?.type&&"raster"===E.getSupportedHeatmapRenderer()?{type:"heatmap"}:{type:"symbol"};const e={};d.map(h=>da(e,a,h));const f=l.isSome(a.subtypeCode)?`${a.subtypeField} = ${a.subtypeCode}`:null;return{source:{definitionExpression:l.unwrap(X.sqlAnd(a.definitionExpression,f)),fields:a.fields.map(h=>h.toJSON()),gdbVersion:a.gdbVersion,historicMoment:a.historicMoment?.getTime(),
outFields:a.availableFields,pixelBuffer:a.pixelBuffer,spatialReference:a.spatialReference.toJSON(),timeExtent:a.timeExtent?.toJSON(),customParameters:a.customParameters},attributes:{fields:{},indexCount:0},processors:d,tileRenderer:c,targets:e}}catch(d){if("ValidationError"===d.fieldName)return v.error(d),null;throw d;}}function da(a,b,c){switch(c.target){case "feature":F(a,G(b),c);break;case "aggregate":if("featureReduction"in b){var d=b.featureReduction;switch(d?.type){case "selection":throw new n("ValidationError",
"Mapview does not support `selection` reduction type",d);case "binning":F(a,G(b),c);ea(a,d,b.fields.map(e=>e.toJSON()),c);break;case "cluster":F(a,G(b),c),fa(a,d,b.fields.map(e=>e.toJSON()),c)}}}}function H(a,b){for(const d in b){const e=b[d];if(e.target===a.name){var c=a.attributes[d];c?.context?(c=c.context,c.mesh=c.mesh||e.context?.mesh,c.storage=c.storage||e.context?.storage):a.attributes[d]=e}}return a}function G(a){return[l.unwrap(a.filter)?.toJSON()??null,l.unwrap(l.unwrap(a.featureEffect)?.filter)?.toJSON()??
null]}function F(a,b,c){a.feature||(a.feature={name:"feature",input:"source",filters:b,attributes:{}});H(a.feature,c.attributes.fields);return a}function P(a,b){const {onStatisticExpression:c,onStatisticField:d,statisticType:e}=a;switch(e){case "min":case "max":case "avg":case "avg_angle":case "sum":case "count":return"esriFieldTypeDouble";case "mode":if(c)return{returnType:b}=c,b?"string"===b?"esriFieldTypeString":"esriFieldTypeDouble":(v.error(new n("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",
a)),"esriFieldTypeString");b=b.find(f=>f.name===d);return b?b.type:(v.error(new n("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",a)),"esriFieldTypeString")}}function ea(a,b,c,d){a.aggregate||(a.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:b.fixedBinLevel,fields:(b.fields??[]).map(e=>({...e.toJSON(),type:P(e,c)}))},attributes:{}});H(a.aggregate,d.attributes.fields);return a}function fa(a,
b,c,d){a.aggregate||(a.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:J.pt2px(b.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(J.pt2px(b.clusterMaxSize)/64),fields:(b.fields??[])?.map(e=>({...e.toJSON(),type:P(e,c)}))}});H(a.aggregate,d.attributes.fields);return a}function r(a,b){return b.field?w(a,{...b,type:"field",field:b.field}):b.valueExpression?w(a,{...b,type:"expression",valueExpression:b.valueExpression}):{field:void 0,fieldIndex:void 0}}
function w(a,b){switch(b.type){case "expression":var c=b.valueExpression;if(!a.fields[c]){var d=a.indexCount++;a.fields[c]={...b,name:c,fieldIndex:d}}return{fieldIndex:a.fields[c].fieldIndex};case "label-expression":return c=JSON.stringify(b.label),a.fields[c]||(d=a.indexCount++,a.fields[c]={...b,name:c,fieldIndex:d}),{fieldIndex:a.fields[c].fieldIndex};case "field":c=b.field;if("aggregate"===b.target&&a.fields[c])return{field:c};a.fields[c]={...b,name:c};return{field:c};case "statistic":return a.fields[b.name]=
{...b},{field:b.name}}}function ca(a,b=!1){const c=[];let d=0;c.push(ha(a,d++,b));return c}function I(a,b,c,d,e,f=!1){a=w(a,{type:"label-expression",target:c,context:{mesh:!0},resultType:"string",label:{labelExpression:b.labelExpression,labelExpressionInfo:b.labelExpressionInfo?{expression:b.labelExpressionInfo.expression}:null,symbol:!!b.symbol,where:b.where}});({fieldIndex:a}=a);return{...p.createSymbolSchema(b,e,f),fieldIndex:a,target:c,index:d}}function ia(a,b,c){const d="featureReduction"in b&&
b.featureReduction;if(!d)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const e=[];let f=null,h=N.toJSONGeometryType(b.geometryType),g=[];var k=null;if(d)switch(d.type){case "selection":return v.error(new n("ValidationError","Mapview does not support `selection` reduction type",d)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case "cluster":case "binning":e.push(...(d.fields??[])),"cluster"===d.type?h="esriGeometryPoint":"binning"===d.type&&(h="esriGeometryPolygon"),
d.renderer&&!d.renderer.authoringInfo?.isAutoGenerated?("cluster"===d.type?{renderer:k}=M.injectDynamicLevelDependentSizeVisualVariable(d.renderer,d,null):k=d.renderer,b=C(d.renderer,d),f=D(a,"aggregate",d.renderer,b,c),g=d&&d.labelsVisible&&d.labelingInfo||[]):"cluster"===d.type&&(k=M.createClusterRenderer(e,b.renderer,d,null,!0),d.symbol&&(b=C(k,d),f={type:"simple",symbol:p.createSymbolSchema(d.symbol,b,c),symbologyType:b.symbologyType}),g=d&&d.labelsVisible&&d.labelingInfo||[])}Q(a,e);return{labels:K.validateLabelingInfo(g,
"binning"===d.type?"esriGeometryPolygon":h),matcher:f,fields:e,rendererOverride:k}}function ha(a,b,c=!1){const d={indexCount:0,fields:{}};var e="featureReduction"in a?a.featureReduction??void 0:void 0;b=e?"aggregate":"feature";if("sublayers"in a){var f={type:"subtype",subtypeField:a.subtypeField,renderers:{},symbologyType:q.WGLSymbologyType.DEFAULT},h={type:"subtype",mapping:{},target:"feature",subtypeField:a.subtypeField},g={type:"subtype",classes:{}},k={type:"symbol",target:"feature",aggregateFields:[],
attributes:d,storage:h,mesh:{matcher:f,aggregateMatcher:null,labels:g,sortKey:null}};e=new Set;let x=0;for(const {renderer:t,subtypeCode:y,labelingInfo:ja,labelsVisible:ka}of a.sublayers){a=0;"visualVariables"in t&&t.visualVariables&&(t.visualVariables.some(A=>"rotation"!==A.type)&&v.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),a=L.getVVFlags(t.visualVariables.filter(A=>"size"!==A.type)));const R={symbologyType:q.WGLSymbologyType.DEFAULT,
vvFlags:a,maxVVSize:0};a=D(d,b,t,R,c);const B=S(d,b,t),T=ka&&ja;if("dictionary"===a.type)throw new n("ValidationError","Dictionary renderer is not supported in subtype layers");if("subtype"===a.type)throw new n("ValidationError","Nested subtype renderers is not supported");if(l.isSome(B)&&"subtype"===B.type)throw new n("ValidationError","Nested subtype storage is not supported");if(l.isSome(B)&&l.isSome(B.attributeMapping))throw new n("ValidationError","Non-visual-variable attributes are not supported in subtype layers");
if("heatmap"===a.type)throw new n("ValidationError","Heatmaps are not supported in subtype layers");if("pie-chart"===a.type)throw new n("ValidationError","Pie-charts are not supported in subtype layers");if(e.has(y))throw new n("ValidationError","Subtype codes for sublayers must be unique");e.add(y);f.renderers[y]=a;h.mapping[y]=B;T&&(g.classes[y]=T.map(A=>I(d,A,"feature",x++,R,c)))}return k}if("heatmap"===a.renderer?.type&&"raster"===E.getSupportedHeatmapRenderer()){const {radius:x,fieldOffset:t,
field:y}=a.renderer;return{type:"heatmap",aggregateFields:[],attributes:d,target:b,storage:null,mesh:{radius:x,fieldOffset:t,field:r(d,{target:b,field:y,resultType:"numeric"}).field}}}f=ia(d,a,c);g=N.toJSONGeometryType(a.geometryType);k=f.rendererOverride??a.renderer;const m=C(k,e);h=D(d,b,k,m,c);k=S(d,b,k);e=la(d,a.orderBy,a.renderer,e);let z=0;a=[...K.validateLabelingInfo(a.labelsVisible&&a.labelingInfo||[],g).map(x=>I(d,x,"feature",z++,m,c)),...f.labels.map(x=>I(d,x,"aggregate",z++,m,c))];return{type:"symbol",
target:b,attributes:d,aggregateFields:f.fields,storage:k,mesh:{matcher:h,labels:{type:"simple",classes:a},aggregateMatcher:f.matcher,sortKey:e}}}function la(a,b,c,d){if(l.isSome(d))return null;if(l.isSome(b)&&b.length){1<b.length&&v.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${b.length}. All but the first will be discarded`);b=b[0];c="ascending"===b.order?"asc":"desc";if(b.field)return{field:b.field,order:c};if(b.valueExpression)return{fieldIndex:w(a,{type:"expression",
target:"feature",valueExpression:b.valueExpression,resultType:"numeric"}).fieldIndex,order:c};v.error(new n("ValidationError","Expected to find a field or valueExpression for OrderByInfo",b));return null}return l.isSome(c)&&"unique-value"===c.type&&c.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function Q(a,b){const c={mesh:!0,storage:!0};for(const d of b){const {name:e,onStatisticField:f,onStatisticExpression:h,statisticType:g}=d;let k=b=void 0;h?k=w(a,{type:"expression",target:"feature",
valueExpression:h.expression,resultType:"numeric"}).fieldIndex:b=w(a,{type:"field",target:"feature",field:f,resultType:"numeric"}).field;w(a,{type:"statistic",target:"aggregate",name:e,context:c,inField:b,inFieldIndex:k,statisticType:g})}}function S(a,b,c){let d;switch(c.type){case "simple":case "class-breaks":case "unique-value":case "dictionary":d={visualVariables:!0,attributes:null};break;default:d=aa.getTechniqueFromRenderer(c).getStorageSpec(c)}return ma(a,b,d,c)}function ma(a,b,c,d){if(l.isNone(c))return null;
const {visualVariables:e,attributes:f}=c;c=null;e&&"visualVariables"in d&&(c=na(a,b,d.visualVariables));const h=l.isSome(c)?4:0;d=null;l.isSome(f)&&(d=f.map((g,k)=>{const {field:m,fieldIndex:z}=r(a,{valueExpression:g.valueExpression,field:g.field,resultType:"numeric",target:b});return{binding:k+h,field:m,fieldIndex:z}}));return{type:"simple",target:b,attributeMapping:d,vvMapping:c}}function na(a,b,c){if(!c||!c.length)return[];const d={storage:!0};return E.simplifyVisualVariables(c).map(e=>{const f=
Z.getVVType(e.type),{field:h,fieldIndex:g}=r(a,{target:b,valueExpression:e.valueExpression,field:e.field,context:d,resultType:"numeric"});switch(e.type){case "size":return"$view.scale"===e.valueExpression?null:{type:"size",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field,valueRepresentation:e.valueRepresentation??null};case "color":return{type:"color",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,
context:d,resultType:"numeric"}).field};case "opacity":return{type:"opacity",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field};case "rotation":return{type:"rotation",binding:f,field:h,fieldIndex:g}}}).filter(l.isSome)}function D(a,b,c,d,e=!1){a=l.unwrapOr(a,{indexCount:0,fields:{}});switch(c.type){case "simple":case "dot-density":return oa(a,c,d,e);case "class-breaks":return pa(a,b,c,d,e);case "unique-value":return qa(a,
b,c,d,e);case "dictionary":return{type:"dictionary",config:c.config,fieldMap:c.fieldMap,scaleExpression:c.scaleExpression,url:c.url,symbolOptions:d,symbologyType:d.symbologyType};case "heatmap":return ra(a,c,d,e);case "pie-chart":return sa(a,c,d,e)}}function oa(a,b,c,d=!1){a=b.getSymbols();return{type:"simple",symbol:p.createSymbolSchema(a.length?a[0]:null,c,d),symbologyType:c.symbologyType}}function sa(a,b,c,d=!1){a=b.getSymbols();b=1<a.length?a[1]:null;return{type:"pie-chart",markerSymbol:p.createSymbolSchema(a[0],
c,d),fillSymbol:p.createSymbolSchema(b,c,d),symbologyType:c.symbologyType}}function pa(a,b,c,d,e=!1){const f=c.backgroundFillSymbol,{field:h,fieldIndex:g}=r(a,{target:b,field:c.field,valueExpression:c.valueExpression,resultType:"numeric",context:{mesh:!0,use:"renderer.field"}});b=c.normalizationType;b="log"===b?"esriNormalizeByLog":"percent-of-total"===b?"esriNormalizeByPercentOfTotal":"field"===b?"esriNormalizeByField":null;const k=c.classBreakInfos.map(m=>({symbol:p.createSymbolSchema(m.symbol,
d,e),min:m.minValue,max:m.maxValue})).sort((m,z)=>m.min-z.min);return{type:"interval",attributes:a.fields,field:h,fieldIndex:g,backgroundFillSymbol:p.createSymbolSchema(f,d,e),defaultSymbol:p.createSymbolSchema(c.defaultSymbol,d,e),intervals:k,normalizationField:c.normalizationField,normalizationTotal:c.normalizationTotal,normalizationType:b,isMaxInclusive:c.isMaxInclusive,symbologyType:d.symbologyType}}function qa(a,b,c,d,e=!1){const f=[],h=c.backgroundFillSymbol;b={target:b,context:{mesh:!0},resultType:"string"};
if(c.field&&"string"!==typeof c.field)throw new n("ValidationError","Expected renderer.field to be a string",c);const {field:g,fieldIndex:k}=r(a,{...b,field:c.field,valueExpression:c.valueExpression});for(const m of c.uniqueValueInfos??[])f.push({value:""+m.value,symbol:p.createSymbolSchema(m.symbol,d,e)});return{type:"map",attributes:a.fields,field:g,fieldIndex:k,field2:r(a,{...b,field:c.field2}).field,field3:r(a,{...b,field:c.field3}).field,fieldDelimiter:c.fieldDelimiter??void 0,backgroundFillSymbol:p.createSymbolSchema(h,
d),defaultSymbol:p.createSymbolSchema(c.defaultSymbol,d),map:f,symbologyType:d.symbologyType}}function ra(a,b,c,d=!1){a=b.getSymbols();return{type:"heatmap",symbol:p.createSymbolSchema(a.length?a[0]:null,c,d),symbologyType:c.symbologyType}}const v=W.getLogger("esri.views.2d.layers.features.schemaUtils");let U=null;u.createSymbolSchema=p.createSymbolSchema;u.addAggregateFields=Q;u.createMatcherSchema=D;u.createRendererAttributeSchema=r;u.createSchema=function(a){if(V("esri-2d-update-debug")){const b=
O(a,!0);console.debug("Created new schema",b);console.debug("Schema diff",Y.diff(U,b));U=b}return O(a)};u.createSymbolSchemaOptions=C;Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});